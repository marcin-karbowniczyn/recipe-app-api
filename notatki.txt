docker-compose run -> Run a one-off command on a service
docker-compose up -> Starts a container
volumes -> tam są zapisane takei rzeczy jak baza danych, czy static files, jak je usuniemy, to je stracimy
dockerfile -> blueprint który tworzy images poprzed dockerfile build
image -> obrazek, z którego tworzony jest container

permission_classes vs authentication_classes
 - The authorization_classes is used for authorization, which is checking if the user says they are who they are.
    This is what checks credentials and checks the token being provided in the requests is correct.
 - The permissions_classes is used to determine what the user is permitted to do.

How to pass data from Views to Serializers:
 - Context are used in Django REST Framework when you want to add extra data to the serializer in addition to the object being serialized.

!!!!!!!!! Odnośnie co wywołuje validatory itd !!!!!!!!!!!
Validators w Modelu:
 - Działają w serializers i django admin (oba wywolują funkcję is_valid())
 - Nie działają w bezpośrednim wywołaniu funkcji object.create(). Do tego musimy dostosować funkcję create() w Managerze
Validators w Serializer:
 - Działają tylko w serializer, a nie w adminie

CustomManager:
- Domyślnie nie działa w adminie, bo ten domyślnie używa konstuktora model() a nie Managera

PUT VS PATCH
PUT updates all the fields of the object on which the operation is to be performed. It basically iterates over all the fields and updates them one by one.
    Thus, if a required field is not found in the supplied data, it will raise an error.
PATCH is what we call a Partial Update. You can update only the fields that are needed to be changed. Thus, in your case change your request method to PATCH and your work will be done.

# Jak tworzony jest obiekt w Django REST Framework
# 1. HTTP request wpada przez URL do Viewsetu
# 2. Vieset wywołuje funkcję create()
# 3. W funkcji create przywołany jest serializer do którego przekazujemy request.data
# 4. Serializer konwertuje dane i przeprowadza walidację
# 5. W funkcji viewset.create() wywołujemy funkcję perform_create(serializer)
# 6. W funkcji perform_create() jako argument przekazujemy serializer i wywołujemy funkcję serializer.save()
# 7. Serializer.save() podaje dodatkowy model field i wywołuje funkcję serializer.create()
# 8. Funkcja serializer.create() wywołuje Managera z modelu który podaliśmy w class Meta i wywołuje jego funkcję crate() i ostatecznie tworzy i zapisuje obiekt w bazie danych.

Prościej: POST req wpada na serwer -> idzie do serializera który testuje fieldy, sprawdza czy hasło ma więcej niż 5 znaków, ustawia że hasło jest write-only itd, ->
        -> następnie daje validated_data do funkcji create(), która tylko wywołuje funkcję create() Managera Modelu, i ta create() managera Modelu zapisuje obiekt w DB (my tworzymy własną funkcję
        create_user(), żeby zrobić hash hasła, bo defaultowa funckaj create() Managera tego nie robi).

!!!!!!!!!!!!!!! Serializers !!!!!!!!!!!!!!!!!!!!!!!!!!!
I did some testing and I found out, that you indeed need a defined serializer. Or maybe I should say, we need serializers when using generic Views like CreateAPIView or RetrieveUpdateAPIView.
If we use these Views without any Serializer, the app would raise a following error:
<Error #2: ManageUserView: exception raised while getting serializer. Hint: Is get_serializer_class() returning None or is get_queryset() not working without a request?
Ignoring the view for now. (Exception: 'ManageUserView' should either include a `serializer_class` attribute, or override the `get_serializer_class()` method.)>
On the other hand, if we were to use some basic Serializer like rest_framework.serializers.Serialize in CreateUser View, we wouldn't be able to pass any data to POST request.
If we had dupa = serializers.Charfield() in this serializer, it would only let us pass this value.

Czym jest serializer.data?
 1. Konwertujemy Model Instance (comment) w Python datatype (dictionary)
    serializer = CommentSerializer(comment)
    serializer.data
    # {'email': 'leila@example.com', 'content': 'foo bar', 'created': '2016-01-27T15:17:10.375877'}

 2. Żeby zakończyć proces serializacji, konwertujemy ten obiekt w JSON
    json = JSONRenderer().render(serializer.data)
    # b'{"email":"leila@example.com","content":"foo bar","created":"2016-01-27T15:17:10.375877"}'




!!!!!!!!!!!!!!!! Tests !!!!!!!!!!!!!!!!!!!!!!!!
Dużo o testach jest w rozdziale o testach na Udemy. Jeśli czegoś zapomnę, warto tam zajrzeć.
The Django test running will look for modules beginning with “test”. For example, this could be a test.py file or tests/test_something.py.
Django test framework:
- Based on the unittest library
- Django adds features:
    - Test client - dummy web broweser to make requests to my project
    - Simulates authentiation
    - Temporary database
 - DRF also adds features
    - API test client

Test classes: (if we want DB quersies -> TestCase, if not -> SimpleTestCase)
 - SimpleTestCase
    - No database intergation
    - Useful if no database is required for your test
    - Save time executing tests
 - TestCase
    - Database integration. Temporary database will be cleared after every test (it can be overriden).
    - Useful for testing code that uses the database

Mocking -> Naśladowanie/mimikowanie, używamy tego, ponieważ dependencje takie jak nasza baza danych, albo zewnętrzne API,
    może być podatne na wewnętrzne problemy, takie jak bugi, brak dostępności itd.
    Z tego względu ustalamy, że chcemy sprawdzić tylko i wyłącznie nasz kod, bo nie mamy wpływu na kod aplikacji zewnętrznych. Mocking polega na mimikowaniu działania zewnętrznych aplikacji.
    Zmieniamy funkcjonowanie poszczególnych funkcji, żeby zamiast wysłania maila, albo requesta, po prostu zwróciły response taki jaki ustalimy. Sprawdzamy czy nasz kod działa poprawnie,
    bez polegania na działaniu zewnętrznych usług. Nie potrzebujemy sprawdzać czy one działają, potrzebujemy sprawdzić, czy nasz kod działa poprawnie.

We can use tests.py or /tests directory, but we cannot use both in one app.
If we use /tests, we need to create __init__.py file, and every test file needs to have a 'test_' prefix.

TDD -> you write tests to drive development

Important: The database is cleared before each test, so the user doesn't exist before that specific test.

 - tearDown(self):
    For the purposes of the database, tearDown is pretty pointless, because each test is run in a transaction.
    However, not everything in a test involves the database. You might test file creation/reading, spin off processes, open network connections, etc.
    These types of things usually require you to "close" them after you're done. This is what tearDown is for, i.e. cleaning up stuff from your setUp method, not related to the database.
    (Though, if you were actually directly connecting to a database, i.e. as the actual Django tests must do to make sure all the DBAPI stuff works properly, you'd need to do clean up there too.)


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! DATABASES !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Models: (Fajnie wytłumaczone w lecture 41.
 - Each model maps to a table in the DB. Every model creates a table
 - Models contain name, fields (columns), metadata (relationships between tables)

python manage.py makemigrations -> Django is smart, it will check my models and compare them with migrations that already exist,
and it will make sure that it adds new migrations if I change anything inside my models, it will add a new migration for that

objects.get_or_create() -> Manager's helper function, it gets the object if it exists, if not it creates it.

DLACZEGO JESTEŚMY W STANIE ZAPISAĆ OBIEKT KTÓRY MA PUSTY CHARFIELD?
 - Dlatego, że Charfield i Textfield w DB domyślnie zapisują się jako emtpy string. blank=True to tylko informacja do admina/form/serializer, że ten field jest wymagany.
 - Na poziomie DB, nie ma on żadnego znaczenia. Tam znaczenie ma null=True. Natomiast Charfield i Textfield nie zapisują się jako Null, tylko domyślnie jako empty string, więc
 - w wypadku tych pól, null=False nie ma żadnej mocy.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! MODELS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
DUŻO WYTŁUMACZONE W LEKCJI 47
- Django comes in with a built-in authentication system
- This system integrates with Django admin
- The default Django User Model is the foundation of the auth system. It includes the data of the users who register to our app using Django auth system.
- It also includes code for authenticating users by checking their username and password.
- We often create a new model and base it from AbstractBaseUser and PermissionsMixin (to customize our user model, change username to email etc.)
- We need to set AUTH_USER_MODEL in settings.py to tell Django what User Model we want to use.
- It is always recommended to set the custom user model first before creating any migrations for the project
- User Model Manager is used to manage objects in the system, we can create any custom logic for creating objects

AbstractBaseUser:
 - Provides features for auth
 - Doesn't include any predefined fields (we need to define them ourselve)

PermissionMixin:
 - It is used for the Django Permission System.
 - It provides all the default system fields and methods that are needed for our user model in order for it to work with the authenticaton system

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! DJANGO ADMIN !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 - Django Admin is a GUI for models that we created
 - It allows basic CRUD
 - Very little coding required
 - We need to enable it per model, inside admin.py (admin.site.register(ModelName))
 - We can customize the Django Admin using ModelAdmin or UserAdmin


 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! API Documentation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Why should we document our API?
- APIs are designed for developers to use, and they need to know how to use it
- An API is only as good as its documentation

What to document?
What to document?
 - Everything needed to use the API
 - Available endpoints (paths) (/api.recipes)
 - Supported methods (HTTP methods: get, post, put, patch, delete), which are enabled for the endpoint and what they do
 - Format of payloads (inputs): query string parameters, POST JSON format
 - Format of responses: response JSON format,
 - Auth process (how we authenticate users with our API)

Options of documentation:
 - Manual:
    - Word doc
    - Markdown Readme
 - Automated:
    - Use metadata from code (comments)
    - From the comments we generate documentation pages

1. DRF-spectacular -> Automatically creates an OpenAPI Schema (YML or JSON) file out of docstrings in our project
2. Swagger -> Takes this Schema and creates a Browsable Wen Interface that is human-readable and allows to test endpoints

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! AUTHENTICATION !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Authentication in DRF is spiltted into two different things, authentication and permission.
Authentication is how do we know who the user is the user he says he is (Token authentication).
Permission is how do we say who has access to the endpoint, or what this user can do in our API

# We need to add this, so Django can add user to the User model's user foreign key field.
# We need to add user manually, since it's not in the req.data, and it's not processed by the serializer.
# request.user will be set by Token Authentication
# Serializer will be the validated serializer
def perform_create(self, serializer):
    """ Create a new recipe """
    serializer.save(user=self.request.user)


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Viewsets vs APIView !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
View:
 - Handles a request made to a URL

APIView:
 - Focused around HTTP methods
 - Class methods for HTTP methods (GET, POST, PUT, PATCH, DELETE)
 - Provide more flexibility over URLs and logic
 - Best for non-CRUD APIs
 - Best for auth, jobs, external apis

Viewsets:
 - Focused around actions
 - Class methods for HTTP methods (Retrieve, list, update, partial update, destroy)
 - Map to Django models
 - Use Routers to generatr URLs



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Media and Static !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
- These are files not generated by Python code (images, javascript, icons)
- Two types:
  - Media - Uploaded by the user at runtime (user uploads images)
  - Static - Generated on build, created with the source code, when we first run the app (images, css, javascript)
- Configs in settings.py:
    - STATIC_URL - Base static URL (/static/static)
    - MEDIA_URL - Base media URL (/static/media/)
    - MEDIA_ROOT - Path to media on filesystem (/vol/web/media)
    - STATIC_ROOT - Path to static files on fielsystem (/vol/web/static)


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Deployment !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
SUPER WYTŁUMACZONE W WIDEO 137 !!
                       / Database
USERS -> REVERSE PROXY
                       \ WSGI Server
WSGI obsługuje requesty, szybko wykonuje python code, ale jest średni w serwowaniu static files (html, css, obrazki, javascript), z tego względu używamy reverse proxy, które zajmuje się static files,
a inne requesty przesyła dalej do WSGI, które wykonuje python code. Czyli NGNIX obsługuje static files, a WSGI resztę requestu (wytłumaczone w 137). Takim proxy jest Nginx, które dodatkowo dodaje
wartswę zabezpieczeń.

- Nginx:
   - open source, fast, secure, production grade










